package sequel

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"log/slog"
	"regexp"
	"runtime"
	"strings"

	"github.com/amirrezaask/pkg/errors"
	"github.com/go-sql-driver/mysql"
)

var operationRegex = map[string]*regexp.Regexp{
	"SELECT": regexp.MustCompile(`FROM\s+(\w+)\s+`),
	"INSERT": regexp.MustCompile(`INTO\s+(\w+)\s+`),
	"UPDATE": regexp.MustCompile(`UPDATE\s+(\w+)\s+`),
	"DELETE": regexp.MustCompile(`FROM\s+(\w+)\s+`),
}

func extractQueryInfo(query string) (queryType, tableName string) {
	query = strings.TrimLeft(query, " \t\n\r") // trim left side
	splited := strings.SplitN(query, " ", 2)   // split with one space
	if len(splited) == 2 && splited[0] != "" {
		firstWord := strings.ToUpper(splited[0])
		maybeRegex, ok := operationRegex[firstWord]
		if ok {
			operation := firstWord
			if maybeRegex != nil {
				if matches := maybeRegex.FindStringSubmatch(query); len(matches) > 1 {
					tableName = matches[1]
					return operation, tableName
				}
			}
			slog.Info("error in categorizing query table", "query", query)
			return operation, "unknown"
		} else {
			slog.Info("error in categorizing query operation", "query", query)
			return "unknown", "unknown"
		}
	} else {
		slog.Info("error in categorizing query", "query", query)
		return "unknown", "unknown"
	}
}

func callerInfo() []string {
	var pc uintptr
	var ok bool
	var file string
	var line int
	var name string

	callers := []string{}
	for i := 0; ; i++ {
		pc, file, line, ok = runtime.Caller(i)
		if !ok {
			// The breaks below failed to terminate the loop, and we ran off the
			// end of the call stack.
			break
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		name = f.Name()

		// testing.tRunner is the standard library function that calls
		// tests. Subtests are called directly by tRunner, without going through
		// the Test/Benchmark/Example function that contains the t.Run calls, so
		// with subtests we should break when we hit tRunner, without adding it
		// to the list of callers.
		if name == "testing.tRunner" {
			break
		}

		parts := strings.Split(file, "/")
		if len(parts) > 1 {
			filename := parts[len(parts)-1]
			rest := strings.Join(parts[:len(parts)-1], "/")
			if (!strings.Contains(rest, "pkg/sequel")) && filename != "sql.go" {
				callers = append(callers, fmt.Sprintf("%s:%d", file, line))
			}
		}
	}
	return callers
}

func debugLog(query string) {
	_, file, line, ok := runtime.Caller(3)
	runtimeInfo := "<unknown caller>"
	if ok {
		runtimeInfo = fmt.Sprintf("file='%s' line=%d", file, line)
	}

	fmt.Printf("%s => %s\n\n", runtimeInfo, query)
}

func dbErrText(err error) string {
	var errText string
	if errors.Is(err, sql.ErrConnDone) {
		errText = "connection_already_closed"
	} else if errors.Is(err, sql.ErrNoRows) {
		errText = "no_rows"
	} else if errors.Is(err, sql.ErrTxDone) {
		errText = "tx_already_done"
	} else if errors.Is(err, driver.ErrBadConn) {
		errText = "bad_connection"
	} else if errors.Is(err, driver.ErrRemoveArgument) {
		errText = "invalid_named_value_argument"
	} else if errors.Is(err, driver.ErrSkip) {
		errText = "skip"
	} else if errors.Is(err, mysql.ErrInvalidConn) {
		errText = "mysql_invalid_connection"
	} else if errors.Is(err, new(mysql.MySQLError)) {
		errText = "mysql_error"
	} else if errors.Is(err, context.DeadlineExceeded) {
		errText = "ctx_deadline"
	} else if errors.Is(err, context.Canceled) {
		errText = "ctx_cancel"
	} else {
		slog.Warn("unhandled database error conversion", "err", err)
		errText = "unhandled"
	}
	return errText
}
